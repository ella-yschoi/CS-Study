# 01. 운영체제 개요

> Reference: [이화여자대학교 운영체제 강의 - 반효경](http://www.kocw.net/home/cview.do?cid=4b9cd4c7178db077)

<br/>

## 운영체제(Operating System, OS)란?

  ![what_OS.png](/Images/what_OS.png)

- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 **모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층**
- 다른 응용 소프트웨어와는 다르게, 하드웨어를 직접 관리하고 편리한 인터페이스를 제공해야 함

<br/>

## 운영체제의 목적

### (1) 컴퓨터 시스템을 **편리하게 사용할 수 있는 환경을 제공**

- 다른 사용자와 프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행

### (2) 컴퓨터 시스템의 **자원을 효율적으로 관리**

- CPU, 메모리, I/O(Input&Output) 장치 등의 효율적 관리
- 주어진 자원으로 최대한의 성능을 내도록 → **효율성**
- 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 → **형평성(round robin 개념)**
- 실행중인 프로그램들에 짧은 시간씩 CPU를 번갈아 할당
- 실행중인 프로그램들에 메모리 공간을 적절히 분배

<br/>

## 컴퓨터 시스템의 구조

  ![computer_system.png](/Images/computer_system.png)

### I/O

- Input
  - 디바이스들에 데이터가 들어가는 것
- Output
  - 결과를 내보내는 것
- e.g. 하드디스크(보조기억장치)
  - Input과 Output을 모두 할 수 있는 장치
  - 처리(Input)와 저장(Output)을 모두 할 수 있음
  - 즉, read와 write를 모두 할 수 있음

<br/>

## 운영체제의 기능

  ![os_function.png](/Images/os_function.png)

- 컴퓨터가 부팅된다 == 메모리에 운영체제가 올라간다.
  - 핵심은 커널: 메모리에 상주하면서 언제나 메모리에 올라와 있는 부분
- 나머지(운영체제가 CPU에게 작동을 스케줄링해서 일하라고 시킨 프로그램 A~C): 메모리 공간을 차지하는 것
  - e.g. 터미널에서 명령어 `htop` 입력하면 나오는 리스트
- CPU의 작업공간 == 메모리
  - CPU는 매 clock마다 기계어를 읽어서 연산을 함
- I/O 디바이스들은 일종의 작은 CPU가 붙어 있음 (I/O 컨트롤러)
  - CPU가 ‘파일을 읽어주세요’ 요청 → 요청된 파일을 읽어서 작은 메모리 공간에 읽음 → CPU에게 다 했다고 함 → CPU 큐에 올라와 있는 일을 실행할 때, CPU가 메모리에 프로그램을 올리고 일을 함

<br/>

## CPU 스케줄링의 개요

  ![cpu_scheduling.png](/Images/cpu_scheduling.png)

- **어떤** 프로그램에게 **얼마동안** CPU 사용권을 줄까?
- CPU가 기계어를 읽어서 시키는 일만 함 (주체가 되지 못하고 상관인 운영체제가 시키는 일만 함. e.g. 되게 똑똑하지만 시키는 일만 하는 아이 같은)
- 운영체제가 가지고 있는 기계어로 CPU에게 시킴 (운영체제의 대행)
- 운영체제가 CPU를 관리할 때는 무한히 쓰게 하지는 않고, 한정된 시간동안만 쓰게 함 → 운영체제는 시간이 지나면 사용권을 빼앗아 오는 역할을 함.
- 단, 하드웨어와 협조해서 스케줄링을 진행함

<br/>

## 메모리 관리의 개요

  ![memory_managing.png](/Images/memory_managing.png)

- 한정된 메모리를 어떻게 쪼개서 쓸까?

<br/>

## 디스크 스케줄링의 개요

  ![disk_scheduling.png](/Images/disk_scheduling.png)

- 요청이 먼저 온 순서대로 처리해도 되지만, 비효율을 유발할 수도 있음.
- 운영체제 목적이 ‘효율성’ 이므로 나중에 들어온 요청이지만 순서를 뒤바꿔서 효율적으로 운영할 수 있도록 할 수 있도록 함
- e.g. 엘레베이터 스케줄링과 유사
  - 10층 사람보다 2층 사람이 버튼을 늦게 눌렀지만 어차피 1층에서 10층 가는 길이라면 2층 사람을 먼저 태워주는 원리

<br/>

## 인터럽트, 캐싱의 개요

빠른 CPU와 느린 I/O 장치 간의 속도 차를 극복할 수 있는 방법

  ![interrupt_caching.png](/Images/interrupt_caching.png)

### Caching(캐싱)

- 중간 단계를 두는 것.
- 디스크에서 파일을 읽어달라는 요청이 왔을 때 처리하는게 아니라 (똑같은 데이터를 또 읽어야 할 수도 있으니) **메모리 어딘가에 보관**해두었다가 메모리의 복제본으로 읽어가는 개념

### Interrupt(인터럽트)

- **느린 I/O들이 작업이 완료되었다는 것을 알린다**
- CPU가 직접 I/O 작업을 하는게 아니라 디스크 컨트롤러에게 파일을 읽어달라고 부탁 → 그동안 CPU는 당장 일할 수 있는 것을 찾음 (→ CPU 스케줄링) 즉, CPU는 빠른 아이이므로 놀게 두지 않고 무엇이든 하게 놔둔다.
- 파일을 다 읽었다면? → 프로그램 A가 요청을 다 읽었다는 것을 CPU에게 전달함 → Interrupt
- 느린 장치들에게 일을 시켜놓고, CPU에게 일 끝났는지 확인하는건 비효율적이므로 시킨 일이 끝나서 CPU에게 연락해야 할 때 (아주 가끔) interrupt를 걸어줌

### Interrupt(인터럽트) 원리 비유

- 팀장이 팀원 A, B, C에게 일을 시킴 → 팀원 A가 일을 다했어요 → 알리는 interrupt 포스트잇으로 남기고 감 → 팀장은 작업이 끝난 후 interrupted 되어서 팀원 A의 일을 확인
- 즉, CPU가 해야 하는 일을 디스크 관련 일을 디스크 컨트롤러에게 임시로 위임했으니, 컨트롤러가 다했으면 → interrupt → 읽는 작업이 완료된 이후 작업 (보여주는 것 등)을 CPU가 함
- Blocking: 팀장이 팀원의 일을 잘 했는지 잡아서 확인한다.
- Non-blocking: 팀장과 팀원의 일을 각자 한다.

<br/>

## 프로세스의 상태

  ![process_queue.png](/Images/process_queue.png)

- CPU가 하나밖에 없기 때문에, 기계어를 실행하는 것이 CPU 안에서 이루어짐
- 나머지들은 CPU를 못쓰고 기다리고 있는데, 운영체제가 CPU 쓰고자 하는 애들에게 '큐'라는 것을 만들어줌 → 짧은 시간동안 빼서 CPU를 쓸 수 있도록 줄세워 둠
- 디스크에 있는 파일을 읽어와야겠다 → 디스크 입출력 큐에 프로세스가 쌓이면 → CPU 스케줄링에 의해 처리됨 → interrupt → 디스크 큐에서 빼서 → CPU 큐에 넣어줌
- Interacive Application
  - 프로그램 중 사람과 interaction하는 프로그램 (게임, 웹서핑 등)
- Scientific Application
  - I/O 작업 없이 CPU만 굉장히 오래 쓰는 프로그램

<br/>

## CPU 스케줄링의 추가 개념

  ![cpu_scheduling.png](/Images/cpu_scheduling.png)

### 역할

- 운영체제의 중요한 역할 중 하나
- 여러 프로그램들이 CPU 사용을 하고자 CPU queue에서 기다릴 때, queue에 있는 작업을 어떤 순서로 실행할지 정하는 것

### 예시

- 프로세스 3개가 CPU를 사용하겠다고 queue에 줄 서 있음
- 도착 시각은 전부 같지만, 간발의 차가 있어서 도착 순서는 p1 → p2 → p3 순
- 사용자가 키보드 입력 → 키보드 컨트롤러가 입력된 내용을 CPU 인터럽트 → 운영체제에게 넘어가서 운영체제가 작업이 들어왔음을 알리며 CPU 큐에 넣음 → 스케줄링이 되어 차례가 됨 → 연산 → 연산 결과를 화면에 출력 → (이 순서를 반복)

### (1) FCFS(First-Come First-Served)

![cpu_FCFS](/Images/cpu_FCFS.png)

- 특징: CPU queue에 **요청이 들어온 순서대로** 스케줄링
- 장점: 요청이 들어온 순서대로 이므로 공평 → **형평성 있음**
- 단점: 먼저 들어온 요청이 CPU를 오래 점유하면 그 뒤에 들어온 작업들의 Average waiting time이 길어짐 → **비효율적**

### (2) SJF (Shortest-Job-First)

![cpu_SJF](/Images/cpu_SJF.png)

- 특징: CPU **사용 시간이 가장 짧은 프로세스**를 **먼저 스케줄링**
- 장점: Minimum average waiting time을 보장 → **효율적**
- 단점
  - 무한정 기다려야 할 수도 (Starvation 발생) → **형평성 낮음**
  - 그래서 사용 시간이 긴 프로그램은 CPU를 영원히 못쓸 수도 있음

### (3) Round Robin(RR)

![cpu_Round_Robin](/Images/cpu_Round_Robin.png)

- 특징
  - 현대에 가장 많이 쓰는 방식
  - 각 프로세스가 **동일한 크기의 CPU 할당 시간**을 가짐
  - 즉, **짧은 시간 내에 번갈아** 쓰게 하는 방식
- 프로세스
  - 할당 시간이 끝나면 Interrupt 가 발생 → CPU를 빼앗기고 → CPU queue의 제일 뒤에 줄을 서는 방식
  - CPU를 짧게 쓰려는 프로그램은 CPU를 얻으면 원하는 만큼 다 쓰고 I/O 하러 나가면 되고, 길게 쓰려는 프로그램은 얻고 빼앗고를 반복 → 처리 시간이 긴 작업은 할당 시간동안 끝마치지 못한 작업을 다시 차례가 됐을 때 이어서 처리 완료 → 마치면 CPU 큐에서 빠져 나감 (단, CPU를 빼앗는 방법은 운영체제가 혼자 불가하고 하드웨어의 도움이 필요)
  - n개의 프로세스가 CPU queue에 있는 경우, 어떤 프로세스도 (n-1)*할당시간 이상 기다리지 않음
- 장점
  - CPU를 길게 쓰려는 프로그램은 큐에서 기다리는 시간이 길어짐
  - 반면, 짧게 쓰려는 프로그램은 기다리는 시간이 짧아짐
  - 즉, 대기시간이 프로세스의 CPU 사용시간에 비례

<br/>

## 메모리 관리의 추가 개념

![memory_swap](/Images/memory_swap.png)

### 가상 메모리

- **메모리에 바로 올라가는게 아니라, 한 단계를 더** 거치기 때문에 존재
- 실제 물리적인 메모리에는 **가상 메모리의 당장 필요한 부분만 쪼개서 올려둠**

### 파일 시스템의 디스크

- 프로그램 실행 파일들이 저장
- **전원이 나가도 내용이 유지됨**

### Swap 영역

- 물리적인 메모리가 다 차면 어떠한 프로세스들을 쫓아 내야 하는데, 그들은 Swap 영역으로 쫓겨남
- 메모리의 연장공간으로 영속 가능한 디스크에 위치
- **전원이 나가면 살아는 있지만 의미가 없음** (이미 해당 process는 실행중이 아니기 때문)

### 그렇다면, 어떤 것을 메모리에서 Swap 영역으로 쫓아 낼까?

![memory_LRU_LFU](/Images/memory_LRU_LFU.png)

- 쪼개지는 단위: ‘페이지’
- 프로세스
  - 미래에 다시 사용될 가능성이 높은 페이지는 쫓아내지 말고,
  - 가까운 미래에 사용될 가능성이 낮은 페이지를 쫓아내야 효율적으로 관리됨
  - 즉, 미래를 모르는 상황에서 미래에 다시 사용될 가능성이 높은 애는 쫓아내지 않는 것
- LRU (Least Recently Used) 방식
  - 가장 오래 전에 참조된 페이지부터 삭제
- LFU (Least Frequently Used) 방식
  - 가장 참조 횟수가 적었던 페이지부터 삭제

<br/>

## 디스크 스케줄링의 추가 개념

  ![disk_scheduling.png](/Images/disk_scheduling.png)

![disk_seektime](/Images/disk_seektime.png)

### 디스크 스케줄링의 필요성

- 접근 시간 중 가장 많이 차지 하는 시간이 디스크 헤드의 이동 시간임 → 따라서 헤드 이동 시간(seek-time)을 최대한 줄여야 함
- 게다가, 헤드 이동 시간 다음으로 회전 지연 시간 또한 가장 많은 시간을 차지함
- 실제로 데이터 전송 시간은 매우 짧음 → 스케줄링이 필요한 이유

### (1) FCFS (First-Come First-Served)

![disk_FCFS](/Images/disk_FCFS.png)

- 특징: 디스크 queue에 요청이 들어온 순서대로 헤드를 이동함
- 단점: 헤드의 이동이 길어짐 → **비효율적**

### (2) SSTF (Shortest Seek Time First)

![disk_SSTF](/Images/disk_SSTF.png)

- 특징: 큐에 들어온 요청 중, 현재 위치에서 seek time이 가장 짧은(가장 가까운)순서로 스케줄링
- 장점: 훨씬 이동거리가 짧아짐 → **효율적**
- 단점: CPU 스케줄링의 단점과도 같음 → **Starvation 문제** 발생

### SCAN

![disk_SCAN](/Images/disk_SCAN.png)

- 특징
  - 큐에 요청이 어떻게 들어와있는지는 관심이 없음.
  - 가는 길목의 모든 요청을 처리함 → ‘내 갈길을 간다!’
  - 엘레베이터 스케줄링의 원리와 유사
- 장점
  - 헤드의 이동거리가 빨라짐 → **효율적**

<br/>

## 저장장치 계층구조와 캐싱의 추가 개념

![save_caching](/Images/save_caching.png)

### 저장장치 계층 구조의 특징

- CPU는 기계어 실행 시 Registers에 있는 값들로 실행
- Registers와 Main Memory 속도 차이를 줄이기 위한 것 → 중간에 Cache Memory를 두어 캐싱
- 현대에는 Main Memory와 Magnetic Disk 사이에 Flash memory가 존재
- 밑으로 내려갈수록 느리고 싸기 때문에 용량을 더 많이 쓸 수 있음

### Primary 영역의 특징

- **휘발성**: 전원이 나갔을 때도 남아있지 않음
- DRAM(Dynamic Random Access Memory: 컴퓨터 메모리에 사용되는 매우 빠른 저장장치)로 구성됨
- 메인 메모리 계층으로, CPU가 직접 접근 및 실행 가능
- 컴퓨터 내부에 위치

### Secondary 영역의 특징

- **비휘발성**: 전원이 나갔을 때 남아있음
- 하드디스크 구성
- CPU가 직접 접근하지 못하기에 primary에 올려놓고 접근
- I/O 장치들

### 계층 구성을 하는 이유

- 속도 차이를 완충하기 위해 layered architecture를 가짐
  - 데이터의 최종적으로 쌓여있는 곳: 아래
  - 위에서 필요하다고 하면 올리고 올려서 처리
  - 저장을 해야 한다면 내리고 내려서 저장

### 어떻게 속도 차이를 완충하나 → **Caching**

- 어떤 데이터가 필요하다고 하면 갖다 올려서 쓰겠지만
- 동일한 데이터를 다시 요청한다면 재사용 시 중간 경로에서 읽어가면 되기 때문
- 즉, 빠른 계층으로 복사해놓고, 그 복사본을 주기만 하면 됨
- 물론 모든 데이터가 다 복사되어 있을 수는 없지만, 메모리 관리 로직처럼 페이지를 쫓아 낼 때 재사용 안될만할 것을 쫓아내야 하는 것임 → 무엇을 보관하고 무엇을 쫓아낼 것인가!

<br/>

## 플래시 메모리

![flash_memory](/Images/flash_memory.png)

### 플래시 메모리란?

- DRAM 등 반도체 장치
- 우리가 사용하는 플래시 매모리는 거의 NAND형 이라고 보면 됨

### 특징

- 하드디스크는 원판을 돌려야 하기에 전력소모가 크나, 플래시 메모리는 전력 소모가 적음
- 물리적인 충격에도 강함
- 들고다니기 편하게 크기가 작고 가벼움
- 따라서 모바일 장치에서 쓰기 좋음 (배터리로 돌아가기 때문에)

### 사용 형태

- 초기에는 모바일 장치에 쓰는 것으로 시작
- 이후에는 하드디스크 대용으로 쓰는 SSD
- 데이터 센터에서도 사용하는 것으로 확장중

### 단점

- 쓰기 횟수에 제약이 있음
- 하드 디스크에 중요한 데이터 넣어두고 오랜 시간이 지나도 웬만하면 읽을 수 있음
- 다만, 플래시 메모리의 데이터는 시간이 흐르면서 변질될 수도 있는 가능성이 있음

<br/>

## 운영체제의 종류

- 서버용, PC용, 스마트디바이스용 운영체제
- 공개 소프트웨어 (Open Source Software)
  - Linux, Android
